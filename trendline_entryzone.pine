//@version=5
indicator("Trendline (Lows, 1H)", overlay=true, max_lines_count=200)

// === Inputs ===
pivotLen = input.int(4, "Pivot Length", minval=1)
trendTf = input.timeframe("60", "Trend Timeframe (1H)")
requireHigherHighs = input.bool(true, "Require Higher Highs (Uptrend)")
requireLowerLows = input.bool(true, "Require Lower Lows (Downtrend)")
maxLines = input.int(10, "Max Recent Trendlines", minval=1, maxval=50)
lineColor = input.color(color.new(color.teal, 0), "Line Color")
downLineColor = input.color(color.new(color.orange, 0), "Downtrend Line Color")
lineWidth = input.int(2, "Line Width", minval=1, maxval=4)
lineStyleOpt = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"])
lineStyle = lineStyleOpt == "Dashed" ? line.style_dashed : lineStyleOpt == "Dotted" ? line.style_dotted : line.style_solid
lengthMult = input.float(1.0, "Line Length Multiplier", minval=0.2, maxval=5.0, step=0.1)
zoneRatio1 = input.float(0.382, "Zone Ratio 1", minval=0.0, maxval=1.0, step=0.01)
zoneRatio2 = input.float(0.786, "Zone Ratio 2", minval=0.0, maxval=1.0, step=0.01)
showZone = input.bool(true, "Show Entry Zone")
zoneLineWidth = input.int(2, "Zone Line Width", minval=1, maxval=5)
historyZones = input.int(200, "History Zones", minval=1, maxval=1000)
upZoneColor = input.color(color.new(color.green, 0), "Up Zone Color")
downZoneColor = input.color(color.new(color.red, 0), "Down Zone Color")
showZoneRefCandles = input.bool(true, "Show Zone Reference Candles")
zoneRefLongColor = input.color(color.new(color.green, 0), "Zone Ref Line Color (Long)")
zoneRefShortColor = input.color(color.new(color.red, 0), "Zone Ref Line Color (Short)")
zoneLineStyle = line.style_dashed
morningSession = input.session("0800-1200", "Tokyo Morning Session")
morningTz = input.string("Asia/Tokyo", "Tokyo Morning Timezone")
showWinrate = input.bool(true, "Show Win Rate")
showDowTrendTable = input.bool(true, "Show Dow Trend Table")
dowTf0 = input.timeframe("5", "Dow TF 0")
dowTf1 = input.timeframe("15", "Dow TF 1")
dowTf2 = input.timeframe("60", "Dow TF 2")
dowTf3 = input.timeframe("240", "Dow TF 3")
dowTf4 = input.timeframe("D", "Dow TF 4")

// === Pivot tracking (time-based) ===
f_pivots_4h() =>
    var int lastLowTime = na
    var float lastLowPrice = na
    var int prevLowTime = na
    var float prevLowPrice = na

    var int lastHighTime = na
    var float lastHighPrice = na
    var int prevHighTime = na
    var float prevHighPrice = na

    ph = ta.pivothigh(high, pivotLen, pivotLen)
    pl = ta.pivotlow(low, pivotLen, pivotLen)

    if not na(ph)
        prevHighTime := lastHighTime
        prevHighPrice := lastHighPrice
        lastHighTime := time[pivotLen]
        lastHighPrice := ph

    if not na(pl)
        prevLowTime := lastLowTime
        prevLowPrice := lastLowPrice
        lastLowTime := time[pivotLen]
        lastLowPrice := pl

    [prevLowTime, lastLowTime, prevLowPrice, lastLowPrice, prevHighTime, lastHighTime, prevHighPrice, lastHighPrice, not na(pl), not na(ph)]

[prevLowTime, lastLowTime, prevLowPrice, lastLowPrice, prevHighTime, lastHighTime, prevHighPrice, lastHighPrice, newPivotLow, newPivotHigh] = request.security(syminfo.tickerid, trendTf, f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)

// === Trend check (higher lows / lower highs) ===
trendOk = not na(prevLowPrice) and not na(lastLowPrice) and lastLowPrice > prevLowPrice
if requireHigherHighs
    trendOk := trendOk and not na(prevHighPrice) and not na(lastHighPrice) and lastHighPrice > prevHighPrice
trendDownOk = not na(prevHighPrice) and not na(lastHighPrice) and lastHighPrice < prevHighPrice
if requireLowerLows
    trendDownOk := trendDownOk and not na(prevLowPrice) and not na(lastLowPrice) and lastLowPrice < prevLowPrice

var line lowTrend = na
var line[] lowTrends = array.new_line()
var line highTrend = na
var line[] highTrends = array.new_line()

// === Zone helpers ===
lowRatio = math.min(zoneRatio1, zoneRatio2)
highRatio = math.max(zoneRatio1, zoneRatio2)
var line zoneTopLine = na
var line zoneBottomLine = na
var line[] zoneHistory = array.new_line()
var line[] zoneRefHistory = array.new_line()
var float lastZoneTop = na
var float lastZoneBottom = na
dayMs = 24 * 60 * 60 * 1000

f_is_in_session(string sess, string tz) =>
    not na(time(timeframe.period, sess, tz))

f_calc_zone(float swingLow, float swingHigh, bool isUp, float rLow, float rHigh) =>
    float zTop = na
    float zBot = na
    if not na(swingLow) and not na(swingHigh)
        float swingRange = swingHigh - swingLow
        if isUp
            zTop := swingHigh - swingRange * rLow
            zBot := swingHigh - swingRange * rHigh
        else
            zTop := swingLow + swingRange * rLow
            zBot := swingLow + swingRange * rHigh
    [zTop, zBot]

f_dow_state(float prevHigh, float lastHigh, float prevLow, float lastLow) =>
    bool up = not na(prevHigh) and not na(lastHigh) and not na(prevLow) and not na(lastLow) and lastHigh > prevHigh and lastLow > prevLow
    bool down = not na(prevHigh) and not na(lastHigh) and not na(prevLow) and not na(lastLow) and lastHigh < prevHigh and lastLow < prevLow
    up ? 1 : down ? -1 : 0

f_dow_label(int state) =>
    state == 1 ? "UP" : state == -1 ? "DOWN" : "RANGE"

f_dow_color(int state) =>
    state == 1 ? color.new(color.lime, 0) : state == -1 ? color.new(color.red, 0) : color.new(color.silver, 0)

f_push_zone_history(int x1, int x2, float top, float bot, color zoneColor, int w, line[] hist, int maxZones) =>
    line l1 = line.new(x1, top, x2, top, xloc=xloc.bar_time, extend=extend.none, color=zoneColor, width=w, style=zoneLineStyle)
    line l2 = line.new(x1, bot, x2, bot, xloc=xloc.bar_time, extend=extend.none, color=zoneColor, width=w, style=zoneLineStyle)
    array.push(hist, l1)
    array.push(hist, l2)
    while array.size(hist) > maxZones * 2
        line old = array.shift(hist)
        if not na(old)
            line.delete(old)

f_draw_zone_current(line prevTop, line prevBot, bool showNow, float top, float bot, bool isUp, color upColor, color downColor, int w) =>
    if not na(prevTop)
        line.delete(prevTop)
    if not na(prevBot)
        line.delete(prevBot)
    line newTop = na
    line newBot = na
    if showNow and not na(top) and not na(bot)
        color zoneColor = isUp ? upColor : downColor
        int zoneStartTime = time[1]
        int zoneEndTime = time
        newTop := line.new(zoneStartTime, top, zoneEndTime, top, xloc=xloc.bar_time, extend=extend.right, color=zoneColor, width=w, style=zoneLineStyle)
        newBot := line.new(zoneStartTime, bot, zoneEndTime, bot, xloc=xloc.bar_time, extend=extend.right, color=zoneColor, width=w, style=zoneLineStyle)
    [newTop, newBot]

if newPivotLow and trendOk and not na(prevLowTime) and not na(lastLowTime) and prevLowTime < lastLowTime
    float seg = lastLowTime - prevLowTime
    int endTime = int(lastLowTime + seg * lengthMult)
    float slopeT = (lastLowPrice - prevLowPrice) / seg
    float endPrice = lastLowPrice + slopeT * float(endTime - lastLowTime)
    lowTrend := line.new(prevLowTime, prevLowPrice, endTime, endPrice, xloc=xloc.bar_time, extend=extend.none, color=lineColor, width=lineWidth, style=lineStyle)
    array.push(lowTrends, lowTrend)
    if array.size(lowTrends) > maxLines
        line.delete(array.shift(lowTrends))

if newPivotHigh and trendDownOk and not na(prevHighTime) and not na(lastHighTime) and prevHighTime < lastHighTime
    float segH = lastHighTime - prevHighTime
    int endTimeH = int(lastHighTime + segH * lengthMult)
    float slopeH = (lastHighPrice - prevHighPrice) / segH
    float endPriceH = lastHighPrice + slopeH * float(endTimeH - lastHighTime)
    highTrend := line.new(prevHighTime, prevHighPrice, endTimeH, endPriceH, xloc=xloc.bar_time, extend=extend.none, color=downLineColor, width=lineWidth, style=lineStyle)
    array.push(highTrends, highTrend)
    if array.size(highTrends) > maxLines
        line.delete(array.shift(highTrends))

bool haveSwingUp = not na(lastHighTime) and not na(lastLowTime) and lastHighTime > lastLowTime and not na(lastHighPrice) and not na(lastLowPrice)
bool haveSwingDown = not na(lastHighTime) and not na(lastLowTime) and lastLowTime > lastHighTime and not na(lastHighPrice) and not na(lastLowPrice)

float zoneTopSeries = na
float zoneBottomSeries = na
float zoneTopTmp = na
float zoneBottomTmp = na
if haveSwingUp
    [zoneTopTmp, zoneBottomTmp] = f_calc_zone(lastLowPrice, lastHighPrice, true, lowRatio, highRatio)
    zoneTopSeries := zoneTopTmp
    zoneBottomSeries := zoneBottomTmp
else if haveSwingDown
    [zoneTopTmp, zoneBottomTmp] = f_calc_zone(lastLowPrice, lastHighPrice, false, lowRatio, highRatio)
    zoneTopSeries := zoneTopTmp
    zoneBottomSeries := zoneBottomTmp

bool inMorning = f_is_in_session(morningSession, morningTz)

var line newTop = na
var line newBot = na
if barstate.islast
    [newTop, newBot] = f_draw_zone_current(zoneTopLine, zoneBottomLine, showZone and inMorning, zoneTopSeries, zoneBottomSeries, haveSwingUp, upZoneColor, downZoneColor, zoneLineWidth)
    zoneTopLine := newTop
    zoneBottomLine := newBot

if barstate.isconfirmed and showZone and inMorning and not na(zoneTopSeries) and not na(zoneBottomSeries)
    bool changed = na(lastZoneTop) or na(lastZoneBottom) or zoneTopSeries != lastZoneTop or zoneBottomSeries != lastZoneBottom
    if changed
        color zoneColor = haveSwingUp ? upZoneColor : downZoneColor
        int x1 = time
        int x2 = time + dayMs
        f_push_zone_history(x1, x2, zoneTopSeries, zoneBottomSeries, zoneColor, zoneLineWidth, zoneHistory, historyZones)
        if showZoneRefCandles and not na(lastLowTime) and not na(lastHighTime) and not na(lastLowPrice) and not na(lastHighPrice)
            color refLineColor = haveSwingUp ? zoneRefLongColor : zoneRefShortColor
            line refLowPivot = line.new(lastLowTime, lastLowPrice, x2, lastLowPrice, xloc=xloc.bar_time, extend=extend.none, color=refLineColor, width=2, style=line.style_dotted)
            line refHighPivot = line.new(lastHighTime, lastHighPrice, x2, lastHighPrice, xloc=xloc.bar_time, extend=extend.none, color=refLineColor, width=2, style=line.style_dotted)
            array.push(zoneRefHistory, refLowPivot)
            array.push(zoneRefHistory, refHighPivot)
            while array.size(zoneRefHistory) > historyZones * 2
                line oldRef = array.shift(zoneRefHistory)
                if not na(oldRef)
                    line.delete(oldRef)
        lastZoneTop := zoneTopSeries
        lastZoneBottom := zoneBottomSeries

// === Entry + Winrate (bounce in zone, TP at prior high/low) ===
var bool inTrade = false
var int tradeDir = 0
var float tpPrice = na
var float slPrice = na
var float entryPrice = na
var int wins = 0
var int losses = 0
var int totalTrades = 0
bool longEntryMark = false
bool shortEntryMark = false

bool bounceLong = inMorning and haveSwingUp and not na(zoneTopSeries) and not na(zoneBottomSeries) and low <= zoneTopSeries and close > zoneTopSeries
bool bounceShort = inMorning and haveSwingDown and not na(zoneTopSeries) and not na(zoneBottomSeries) and high >= zoneBottomSeries and close < zoneBottomSeries

if not inTrade
    if bounceLong and not na(lastHighPrice) and not na(lastLowPrice) and lastHighPrice > lastLowPrice
        inTrade := true
        tradeDir := 1
        entryPrice := close
        tpPrice := lastHighPrice
        slPrice := lastLowPrice
        totalTrades += 1
        longEntryMark := true
    else if bounceShort and not na(lastHighPrice) and not na(lastLowPrice) and lastLowPrice < lastHighPrice
        inTrade := true
        tradeDir := -1
        entryPrice := close
        tpPrice := lastLowPrice
        slPrice := lastHighPrice
        totalTrades += 1
        shortEntryMark := true

if inTrade
    bool win = false
    bool loss = false
    if tradeDir == 1
        win := high >= tpPrice
        loss := low <= slPrice and not win
    else if tradeDir == -1
        win := low <= tpPrice
        loss := high >= slPrice and not win

    if win
        wins += 1
        inTrade := false
        tradeDir := 0
    else if loss
        losses += 1
        inTrade := false
        tradeDir := 0

plotshape(longEntryMark, title="Long Entry", style=shape.triangleup, location=location.belowbar, color=color.new(color.lime, 0), size=size.small, text="L")
plotshape(shortEntryMark, title="Short Entry", style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.small, text="S")

// === Dow trend table (multi-timeframe) ===
[_, _, d0PrevLow, d0LastLow, _, _, d0PrevHigh, d0LastHigh, _, _] = request.security(syminfo.tickerid, dowTf0, f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)
[_, _, d1PrevLow, d1LastLow, _, _, d1PrevHigh, d1LastHigh, _, _] = request.security(syminfo.tickerid, dowTf1, f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)
[_, _, d2PrevLow, d2LastLow, _, _, d2PrevHigh, d2LastHigh, _, _] = request.security(syminfo.tickerid, dowTf2, f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)
[_, _, d3PrevLow, d3LastLow, _, _, d3PrevHigh, d3LastHigh, _, _] = request.security(syminfo.tickerid, dowTf3, f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)
[_, _, d4PrevLow, d4LastLow, _, _, d4PrevHigh, d4LastHigh, _, _] = request.security(syminfo.tickerid, dowTf4, f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)

int dow0 = f_dow_state(d0PrevHigh, d0LastHigh, d0PrevLow, d0LastLow)
int dow1 = f_dow_state(d1PrevHigh, d1LastHigh, d1PrevLow, d1LastLow)
int dow2 = f_dow_state(d2PrevHigh, d2LastHigh, d2PrevLow, d2LastLow)
int dow3 = f_dow_state(d3PrevHigh, d3LastHigh, d3PrevLow, d3LastLow)
int dow4 = f_dow_state(d4PrevHigh, d4LastHigh, d4PrevLow, d4LastLow)

var table dowTable = table.new(position.bottom_right, 2, 6, bgcolor=color.new(color.black, 80))
if barstate.islast and showDowTrendTable
    table.cell(dowTable, 0, 0, "TF", text_color=color.white)
    table.cell(dowTable, 1, 0, "Trend", text_color=color.white)
    table.cell(dowTable, 0, 1, dowTf0, text_color=color.white)
    table.cell(dowTable, 1, 1, f_dow_label(dow0), text_color=f_dow_color(dow0))
    table.cell(dowTable, 0, 2, dowTf1, text_color=color.white)
    table.cell(dowTable, 1, 2, f_dow_label(dow1), text_color=f_dow_color(dow1))
    table.cell(dowTable, 0, 3, dowTf2, text_color=color.white)
    table.cell(dowTable, 1, 3, f_dow_label(dow2), text_color=f_dow_color(dow2))
    table.cell(dowTable, 0, 4, dowTf3, text_color=color.white)
    table.cell(dowTable, 1, 4, f_dow_label(dow3), text_color=f_dow_color(dow3))
    table.cell(dowTable, 0, 5, dowTf4, text_color=color.white)
    table.cell(dowTable, 1, 5, f_dow_label(dow4), text_color=f_dow_color(dow4))

// === Stats table ===
var table stats = table.new(position.top_right, 2, 3, bgcolor=color.new(color.black, 80))
if barstate.islast and showWinrate
    int total = wins + losses
    float winrate = total > 0 ? wins * 100.0 / total : na
    table.cell(stats, 0, 0, "Win Rate", text_color=color.white)
    table.cell(stats, 1, 0, total > 0 ? str.format("{0,number,#.##}%", winrate) : "N/A", text_color=color.white)
    table.cell(stats, 0, 1, "W/L", text_color=color.white)
    table.cell(stats, 1, 1, str.format("{0}/{1}", wins, losses), text_color=color.white)
    table.cell(stats, 0, 2, "Trades", text_color=color.white)
    table.cell(stats, 1, 2, str.format("{0}", totalTrades), text_color=color.white)
