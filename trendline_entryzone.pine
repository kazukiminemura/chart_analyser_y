//@version=5
indicator("Trendline (Lows, 1H)", overlay=true, max_lines_count=200)

// === Inputs ===
pivotLen = input.int(4, "Pivot Length", minval=1)
trendTf = input.timeframe("60", "Trend Timeframe (1H)")
showH4Trendlines = input.bool(true, "Show H4 Trendlines")
showDailyTrendlines = input.bool(true, "Show Daily Trendlines")
requireHigherHighs = input.bool(true, "Require Higher Highs (Uptrend)")
requireLowerLows = input.bool(true, "Require Lower Lows (Downtrend)")
maxLines = input.int(10, "Max Recent Trendlines", minval=1, maxval=50)
lineColor = input.color(color.new(color.teal, 0), "Line Color")
downLineColor = input.color(color.new(color.orange, 0), "Downtrend Line Color")
h4UpLineColor = input.color(color.new(color.blue, 0), "H4 Uptrend Line Color")
h4DownLineColor = input.color(color.new(color.yellow, 0), "H4 Downtrend Line Color")
dailyUpLineColor = input.color(color.new(color.aqua, 0), "Daily Uptrend Line Color")
dailyDownLineColor = input.color(color.new(color.fuchsia, 0), "Daily Downtrend Line Color")
lineWidth = input.int(2, "Line Width", minval=1, maxval=4)
lineStyleOpt = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"])
lineStyle = lineStyleOpt == "Dashed" ? line.style_dashed : lineStyleOpt == "Dotted" ? line.style_dotted : line.style_solid
lengthMult = input.float(1.0, "Line Length Multiplier", minval=0.2, maxval=5.0, step=0.1)
zoneRatio1 = input.float(0.382, "Zone Ratio 1", minval=0.0, maxval=1.0, step=0.01)
zoneRatio2 = input.float(0.786, "Zone Ratio 2", minval=0.0, maxval=1.0, step=0.01)
showZone = input.bool(true, "Show Entry Zone")
zoneLineWidth = input.int(2, "Zone Line Width", minval=1, maxval=5)
historyZones = input.int(200, "History Zones", minval=1, maxval=1000)
upZoneColor = input.color(color.new(color.green, 0), "Up Zone Color")
downZoneColor = input.color(color.new(color.red, 0), "Down Zone Color")
showZoneRefCandles = input.bool(true, "Show Zone Reference Candles")
zoneRefLongColor = input.color(color.new(color.green, 0), "Zone Ref Line Color (Long)")
zoneRefShortColor = input.color(color.new(color.red, 0), "Zone Ref Line Color (Short)")
zoneLineStyle = line.style_dashed
morningSession = input.session("0800-1200", "Tokyo Morning Session")
morningTz = input.string("Asia/Tokyo", "Tokyo Morning Timezone")
showWinrate = input.bool(true, "Show Win Rate")
showDowTrendTable = input.bool(true, "Show Dow Trend Table")
showScenarioTable = input.bool(true, "Show Scenario Text")
scenarioPositionOpt = input.string("Top Left", "Scenario Position", options=["Top Left", "Top Center", "Top Right", "Bottom Left", "Bottom Center", "Bottom Right"])
dowTf0 = input.timeframe("5", "Dow TF 0")
dowTf1 = input.timeframe("15", "Dow TF 1")
dowTf2 = input.timeframe("60", "Dow TF 2")
dowTf3 = input.timeframe("240", "Dow TF 3")
dowTf4 = input.timeframe("D", "Dow TF 4")
yosugaReversalBars = input.int(200, "Yosuga: Max Bars After Reversal", minval=5, maxval=1000)
yosugaBreakBufferTicks = input.int(0, "Yosuga: Break Buffer (Ticks)", minval=0, maxval=20)
yosugaRequireZone = input.bool(true, "Yosuga: Require Pullback In Zone")
yosugaRequireRecentReversal = input.bool(false, "Yosuga: Require Recent Reversal")
yosugaRequireHtfAlign = input.bool(false, "Yosuga: Require D/H4 Alignment")
showEntryCandidates = input.bool(true, "Show All Entry Candidates")

// === Constants ===
DIR_NONE = 0
DIR_LONG = 1
DIR_SHORT = -1
RESULT_NONE = 0
RESULT_WIN = 1
RESULT_LOSS = -1
MOMENTUM_NEUTRAL = 0
MOMENTUM_ACCEL = 1
MOMENTUM_DECEL = -1

// === Pivot tracking (time-based) ===
f_pivots_4h() =>
    var int lastLowTime = na
    var float lastLowPrice = na
    var int prevLowTime = na
    var float prevLowPrice = na

    var int lastHighTime = na
    var float lastHighPrice = na
    var int prevHighTime = na
    var float prevHighPrice = na

    ph = ta.pivothigh(high, pivotLen, pivotLen)
    pl = ta.pivotlow(low, pivotLen, pivotLen)

    if not na(ph)
        prevHighTime := lastHighTime
        prevHighPrice := lastHighPrice
        lastHighTime := time[pivotLen]
        lastHighPrice := ph

    if not na(pl)
        prevLowTime := lastLowTime
        prevLowPrice := lastLowPrice
        lastLowTime := time[pivotLen]
        lastLowPrice := pl

    [prevLowTime, lastLowTime, prevLowPrice, lastLowPrice, prevHighTime, lastHighTime, prevHighPrice, lastHighPrice, not na(pl), not na(ph)]

[prevLowTime, lastLowTime, prevLowPrice, lastLowPrice, prevHighTime, lastHighTime, prevHighPrice, lastHighPrice, newPivotLow, newPivotHigh] = request.security(syminfo.tickerid, trendTf, f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)
[h4PrevLowTime, h4LastLowTime, h4PrevLowPrice, h4LastLowPrice, h4PrevHighTime, h4LastHighTime, h4PrevHighPrice, h4LastHighPrice, h4NewPivotLow, h4NewPivotHigh] = request.security(syminfo.tickerid, "240", f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)
[dPrevLowTime, dLastLowTime, dPrevLowPrice, dLastLowPrice, dPrevHighTime, dLastHighTime, dPrevHighPrice, dLastHighPrice, dNewPivotLow, dNewPivotHigh] = request.security(syminfo.tickerid, "D", f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)

var line lowTrend = na
var line[] lowTrends = array.new_line()
var line highTrend = na
var line[] highTrends = array.new_line()
var line h4LowTrend = na
var line[] h4LowTrends = array.new_line()
var line h4HighTrend = na
var line[] h4HighTrends = array.new_line()
var line dLowTrend = na
var line[] dLowTrends = array.new_line()
var line dHighTrend = na
var line[] dHighTrends = array.new_line()

// === Zone helpers ===
lowRatio = math.min(zoneRatio1, zoneRatio2)
highRatio = math.max(zoneRatio1, zoneRatio2)
var line zoneTopLine = na
var line zoneBottomLine = na
var line[] zoneHistory = array.new_line()
var line[] zoneRefHistory = array.new_line()
var float lastZoneTop = na
var float lastZoneBottom = na
dayMs = 24 * 60 * 60 * 1000

f_is_in_session(string sess, string tz) =>
    not na(time(timeframe.period, sess, tz))

f_dow_state(float prevHigh, float lastHigh, float prevLow, float lastLow) =>
    bool up = not na(prevHigh) and not na(lastHigh) and not na(prevLow) and not na(lastLow) and lastHigh > prevHigh and lastLow > prevLow
    bool down = not na(prevHigh) and not na(lastHigh) and not na(prevLow) and not na(lastLow) and lastHigh < prevHigh and lastLow < prevLow
    up ? 1 : down ? -1 : 0

f_dow_label(int state) =>
    state == 1 ? "UP" : state == -1 ? "DOWN" : "RANGE"

f_dow_color(int state) =>
    state == 1 ? color.new(color.lime, 0) : state == -1 ? color.new(color.red, 0) : color.new(color.silver, 0)

f_bias_label(int dState, int h4State) =>
    dState == 1 and h4State == 1 ? "BULLISH" : dState == -1 and h4State == -1 ? "BEARISH" : "NEUTRAL"

f_zone_label(bool inZone) =>
    inZone ? "IN ZONE" : "OUT OF ZONE"

f_momentum_state(float prevHigh, float lastHigh, float prevLow, float lastLow) =>
    bool hasData = not na(prevHigh) and not na(lastHigh) and not na(prevLow) and not na(lastLow)
    int state = MOMENTUM_NEUTRAL
    if hasData
        bool higherHigh = lastHigh > prevHigh
        bool lowerHigh = lastHigh < prevHigh
        bool higherLow = lastLow > prevLow
        bool lowerLow = lastLow < prevLow
        bool oneSideUp = higherHigh and higherLow
        bool oneSideDown = lowerHigh and lowerLow
        // Principle:
        // Accelerating only when both pivots keep moving in one direction.
        // Any failure to keep that structure (including range/mixed swings) is decelerating.
        state := oneSideUp or oneSideDown ? MOMENTUM_ACCEL : MOMENTUM_DECEL
    state

f_momentum_label(int state) =>
    state == MOMENTUM_ACCEL ? "ACCEL" : state == MOMENTUM_DECEL ? "DECEL" : "NEUTRAL"

f_momentum_color(int state) =>
    state == MOMENTUM_ACCEL ? color.new(color.lime, 0) : state == MOMENTUM_DECEL ? color.new(color.orange, 0) : color.new(color.silver, 0)

f_is_uptrend(float prevLow, float lastLow, bool needHigherHighs, float prevHigh, float lastHigh) =>
    bool ok = not na(prevLow) and not na(lastLow) and lastLow > prevLow
    if needHigherHighs
        ok := ok and not na(prevHigh) and not na(lastHigh) and lastHigh > prevHigh
    ok

f_is_downtrend(float prevHigh, float lastHigh, bool needLowerLows, float prevLow, float lastLow) =>
    bool ok = not na(prevHigh) and not na(lastHigh) and lastHigh < prevHigh
    if needLowerLows
        ok := ok and not na(prevLow) and not na(lastLow) and lastLow < prevLow
    ok

f_project_trendline(int startTime, float startPrice, int pivotTime, float pivotPrice, float lenMult, color lnColor, int w, style) =>
    line projected = na
    if not na(startTime) and not na(pivotTime) and startTime < pivotTime and not na(startPrice) and not na(pivotPrice)
        float seg = pivotTime - startTime
        int endTime = int(pivotTime + seg * lenMult)
        float slope = (pivotPrice - startPrice) / seg
        float endPrice = pivotPrice + slope * float(endTime - pivotTime)
        projected := line.new(startTime, startPrice, endTime, endPrice, xloc=xloc.bar_time, extend=extend.none, color=lnColor, width=w, style=style)
    projected

f_push_recent_line(line[] hist, line ln, int maxCount) =>
    if not na(ln)
        array.push(hist, ln)
    while array.size(hist) > maxCount
        line old = array.shift(hist)
        if not na(old)
            line.delete(old)

f_swing_dir(int lastHighT, int lastLowT, float lastHighP, float lastLowP) =>
    bool hasData = not na(lastHighT) and not na(lastLowT) and not na(lastHighP) and not na(lastLowP)
    hasData ? (lastHighT > lastLowT ? DIR_LONG : lastLowT > lastHighT ? DIR_SHORT : DIR_NONE) : DIR_NONE

f_zone_from_swing(int swingDir, float swingLow, float swingHigh, float rLow, float rHigh) =>
    float zTop = na
    float zBot = na
    if not na(swingLow) and not na(swingHigh)
        float swingRange = swingHigh - swingLow
        if swingDir == DIR_LONG
            zTop := swingHigh - swingRange * rLow
            zBot := swingHigh - swingRange * rHigh
        else if swingDir == DIR_SHORT
            zTop := swingLow + swingRange * rLow
            zBot := swingLow + swingRange * rHigh
    [zTop, zBot]

f_price_in_zone(float price, float top, float bot) =>
    bool inZone = false
    if not na(price) and not na(top) and not na(bot)
        float lower = math.min(top, bot)
        float upper = math.max(top, bot)
        inZone := price >= lower and price <= upper
    inZone

f_pivot_in_zone(float pivotPrice, bool swingOk, float zoneTopAtPivot, float zoneBottomAtPivot) =>
    swingOk and not na(pivotPrice) and f_price_in_zone(pivotPrice, zoneTopAtPivot, zoneBottomAtPivot)

f_recent_reversal_ok(bool reversalSignal, int maxBars, bool requireRecent) =>
    int barsSinceReversal = ta.barssince(reversalSignal)
    bool isRecent = not na(barsSinceReversal) and barsSinceReversal <= maxBars
    requireRecent ? isRecent : true

f_htf_alignment_ok(int dir, int dState, int h4State, bool requireAlign) =>
    if not requireAlign
        true
    else
        dir == DIR_LONG ? (dState != -1 and h4State != -1) : dir == DIR_SHORT ? (dState != 1 and h4State != 1) : false

f_zone_gate_ok(bool requireZone, bool pivotInZone, float pivotValue) =>
    requireZone ? pivotInZone : not na(pivotValue)

f_break_price(int dir, float pivotHigh, float pivotLow, int bufferTicks) =>
    float price = na
    if dir == DIR_LONG and not na(pivotHigh)
        price := pivotHigh + syminfo.mintick * bufferTicks
    else if dir == DIR_SHORT and not na(pivotLow)
        price := pivotLow - syminfo.mintick * bufferTicks
    price

f_break_confirmed(int dir, float breakPrice) =>
    not na(breakPrice) and (dir == DIR_LONG ? high >= breakPrice : dir == DIR_SHORT ? low <= breakPrice : false)

f_side_structure_ok(int dir, int trend1hState, bool recentOk, bool htfOk) =>
    dir == DIR_LONG ? trend1hState == 1 and recentOk and htfOk : dir == DIR_SHORT ? trend1hState == -1 and recentOk and htfOk : false

f_dow_state_on_tf(string tf) =>
    [_, _, prevLow, lastLow, _, _, prevHigh, lastHigh, _, _] = request.security(syminfo.tickerid, tf, f_pivots_4h(), barmerge.gaps_off, barmerge.lookahead_off)
    f_dow_state(prevHigh, lastHigh, prevLow, lastLow)

f_trade_levels(int dir, float swingHigh, float swingLow) =>
    float tp = na
    float sl = na
    bool valid = false
    if dir == DIR_LONG and not na(swingHigh) and not na(swingLow) and swingHigh > swingLow
        tp := swingHigh
        sl := swingLow
        valid := true
    else if dir == DIR_SHORT and not na(swingHigh) and not na(swingLow) and swingLow < swingHigh
        tp := swingLow
        sl := swingHigh
        valid := true
    [tp, sl, valid]

f_trade_result(int dir, float tp, float sl) =>
    int result = RESULT_NONE
    if dir == DIR_LONG
        bool win = high >= tp
        bool loss = low <= sl and not win
        result := win ? RESULT_WIN : loss ? RESULT_LOSS : RESULT_NONE
    else if dir == DIR_SHORT
        bool win = low <= tp
        bool loss = high >= sl and not win
        result := win ? RESULT_WIN : loss ? RESULT_LOSS : RESULT_NONE
    result

f_count_wins_losses(int[] results) =>
    int wins = 0
    int losses = 0
    int n = array.size(results)
    if n > 0
        for i = 0 to n - 1
            int r = array.get(results, i)
            if r == RESULT_WIN
                wins += 1
            else if r == RESULT_LOSS
                losses += 1
    [wins, losses]

f_set_dow_row(table t, int row, string tf, int state) =>
    table.cell(t, 0, row, tf, text_color=color.white)
    table.cell(t, 1, row, f_dow_label(state), text_color=f_dow_color(state))

f_push_zone_history(int x1, int x2, float top, float bot, color zoneColor, int w, line[] hist, int maxZones) =>
    line l1 = line.new(x1, top, x2, top, xloc=xloc.bar_time, extend=extend.none, color=zoneColor, width=w, style=zoneLineStyle)
    line l2 = line.new(x1, bot, x2, bot, xloc=xloc.bar_time, extend=extend.none, color=zoneColor, width=w, style=zoneLineStyle)
    array.push(hist, l1)
    array.push(hist, l2)
    while array.size(hist) > maxZones * 2
        line old = array.shift(hist)
        if not na(old)
            line.delete(old)

f_draw_zone_current(line prevTop, line prevBot, bool showNow, float top, float bot, bool isUp, color upColor, color downColor, int w) =>
    if not na(prevTop)
        line.delete(prevTop)
    if not na(prevBot)
        line.delete(prevBot)
    line newTop = na
    line newBot = na
    if showNow and not na(top) and not na(bot)
        color zoneColor = isUp ? upColor : downColor
        int zoneStartTime = time[1]
        int zoneEndTime = time
        newTop := line.new(zoneStartTime, top, zoneEndTime, top, xloc=xloc.bar_time, extend=extend.right, color=zoneColor, width=w, style=zoneLineStyle)
        newBot := line.new(zoneStartTime, bot, zoneEndTime, bot, xloc=xloc.bar_time, extend=extend.right, color=zoneColor, width=w, style=zoneLineStyle)
    [newTop, newBot]

// === Trend check (higher lows / lower highs) ===
trendOk = f_is_uptrend(prevLowPrice, lastLowPrice, requireHigherHighs, prevHighPrice, lastHighPrice)
trendDownOk = f_is_downtrend(prevHighPrice, lastHighPrice, requireLowerLows, prevLowPrice, lastLowPrice)
h4TrendOk = f_is_uptrend(h4PrevLowPrice, h4LastLowPrice, requireHigherHighs, h4PrevHighPrice, h4LastHighPrice)
h4TrendDownOk = f_is_downtrend(h4PrevHighPrice, h4LastHighPrice, requireLowerLows, h4PrevLowPrice, h4LastLowPrice)
dTrendOk = f_is_uptrend(dPrevLowPrice, dLastLowPrice, requireHigherHighs, dPrevHighPrice, dLastHighPrice)
dTrendDownOk = f_is_downtrend(dPrevHighPrice, dLastHighPrice, requireLowerLows, dPrevLowPrice, dLastLowPrice)

if newPivotLow and trendOk
    lowTrend := f_project_trendline(prevLowTime, prevLowPrice, lastLowTime, lastLowPrice, lengthMult, lineColor, lineWidth, lineStyle)
    f_push_recent_line(lowTrends, lowTrend, maxLines)

if newPivotHigh and trendDownOk
    highTrend := f_project_trendline(prevHighTime, prevHighPrice, lastHighTime, lastHighPrice, lengthMult, downLineColor, lineWidth, lineStyle)
    f_push_recent_line(highTrends, highTrend, maxLines)

if showH4Trendlines and h4NewPivotLow and h4TrendOk
    h4LowTrend := f_project_trendline(h4PrevLowTime, h4PrevLowPrice, h4LastLowTime, h4LastLowPrice, lengthMult, h4UpLineColor, lineWidth, lineStyle)
    f_push_recent_line(h4LowTrends, h4LowTrend, maxLines)

if showH4Trendlines and h4NewPivotHigh and h4TrendDownOk
    h4HighTrend := f_project_trendline(h4PrevHighTime, h4PrevHighPrice, h4LastHighTime, h4LastHighPrice, lengthMult, h4DownLineColor, lineWidth, lineStyle)
    f_push_recent_line(h4HighTrends, h4HighTrend, maxLines)

if showDailyTrendlines and dNewPivotLow and dTrendOk
    dLowTrend := f_project_trendline(dPrevLowTime, dPrevLowPrice, dLastLowTime, dLastLowPrice, lengthMult, dailyUpLineColor, lineWidth, lineStyle)
    f_push_recent_line(dLowTrends, dLowTrend, maxLines)

if showDailyTrendlines and dNewPivotHigh and dTrendDownOk
    dHighTrend := f_project_trendline(dPrevHighTime, dPrevHighPrice, dLastHighTime, dLastHighPrice, lengthMult, dailyDownLineColor, lineWidth, lineStyle)
    f_push_recent_line(dHighTrends, dHighTrend, maxLines)

int swingDir = f_swing_dir(lastHighTime, lastLowTime, lastHighPrice, lastLowPrice)
bool haveSwingUp = swingDir == DIR_LONG
bool haveSwingDown = swingDir == DIR_SHORT
[zoneTopSeries, zoneBottomSeries] = f_zone_from_swing(swingDir, lastLowPrice, lastHighPrice, lowRatio, highRatio)
int trend1h = f_dow_state(prevHighPrice, lastHighPrice, prevLowPrice, lastLowPrice)
int trend4h = f_dow_state(h4PrevHighPrice, h4LastHighPrice, h4PrevLowPrice, h4LastLowPrice)
int trendD = f_dow_state(dPrevHighPrice, dLastHighPrice, dPrevLowPrice, dLastLowPrice)
int momentum1h = f_momentum_state(prevHighPrice, lastHighPrice, prevLowPrice, lastLowPrice)
bool longAligned = trendD == 1 and trend4h == 1 and trend1h != -1
bool shortAligned = trendD == -1 and trend4h == -1 and trend1h != 1

bool inMorning = f_is_in_session(morningSession, morningTz)

if barstate.islast
    [newTop, newBot] = f_draw_zone_current(zoneTopLine, zoneBottomLine, showZone and inMorning, zoneTopSeries, zoneBottomSeries, haveSwingUp, upZoneColor, downZoneColor, zoneLineWidth)
    zoneTopLine := newTop
    zoneBottomLine := newBot

if barstate.isconfirmed and showZone and inMorning and not na(zoneTopSeries) and not na(zoneBottomSeries)
    bool changed = na(lastZoneTop) or na(lastZoneBottom) or zoneTopSeries != lastZoneTop or zoneBottomSeries != lastZoneBottom
    if changed
        color zoneColor = haveSwingUp ? upZoneColor : downZoneColor
        int x1 = time
        int x2 = time + dayMs
        f_push_zone_history(x1, x2, zoneTopSeries, zoneBottomSeries, zoneColor, zoneLineWidth, zoneHistory, historyZones)
        if showZoneRefCandles and not na(lastLowTime) and not na(lastHighTime) and not na(lastLowPrice) and not na(lastHighPrice)
            color refLineColor = haveSwingUp ? zoneRefLongColor : zoneRefShortColor
            line refLowPivot = line.new(lastLowTime, lastLowPrice, x2, lastLowPrice, xloc=xloc.bar_time, extend=extend.none, color=refLineColor, width=2, style=line.style_dotted)
            line refHighPivot = line.new(lastHighTime, lastHighPrice, x2, lastHighPrice, xloc=xloc.bar_time, extend=extend.none, color=refLineColor, width=2, style=line.style_dotted)
            array.push(zoneRefHistory, refLowPivot)
            array.push(zoneRefHistory, refHighPivot)
            while array.size(zoneRefHistory) > historyZones * 2
                line oldRef = array.shift(zoneRefHistory)
                if not na(oldRef)
                    line.delete(oldRef)
        lastZoneTop := zoneTopSeries
        lastZoneBottom := zoneBottomSeries

// === Entry + Winrate (pivot in zone, TP at prior high/low) ===
var bool inTrade = false
var int tradeDir = DIR_NONE
var float tpPrice = na
var float slPrice = na
var float entryPrice = na
var int entryBarIndex = na
var int[] closedTradeResults = array.new_int()  // RESULT_WIN / RESULT_LOSS
var line activeTpLine = na
var line activeSlLine = na
bool longEntryMark = false
bool shortEntryMark = false

float entryPivotLow = ta.pivotlow(low, pivotLen, pivotLen)
float entryPivotHigh = ta.pivothigh(high, pivotLen, pivotLen)
float zoneTopAtPivot = zoneTopSeries[pivotLen]
float zoneBottomAtPivot = zoneBottomSeries[pivotLen]
float pivotRefHigh = high[pivotLen]
float pivotRefLow = low[pivotLen]
bool pivotLongInZone = f_pivot_in_zone(entryPivotLow, haveSwingUp[pivotLen], zoneTopAtPivot, zoneBottomAtPivot)
bool pivotShortInZone = f_pivot_in_zone(entryPivotHigh, haveSwingDown[pivotLen], zoneTopAtPivot, zoneBottomAtPivot)
bool closeInEntryZoneNow = f_price_in_zone(close, zoneTopSeries, zoneBottomSeries)
bool bullReversal = trend1h == 1 and trend1h[1] != 1
bool bearReversal = trend1h == -1 and trend1h[1] != -1
bool recentBullReversalOk = f_recent_reversal_ok(bullReversal, yosugaReversalBars, yosugaRequireRecentReversal)
bool recentBearReversalOk = f_recent_reversal_ok(bearReversal, yosugaReversalBars, yosugaRequireRecentReversal)
bool zoneLongOk = f_zone_gate_ok(yosugaRequireZone, pivotLongInZone, entryPivotLow)
bool zoneShortOk = f_zone_gate_ok(yosugaRequireZone, pivotShortInZone, entryPivotHigh)
bool htfLongOk = f_htf_alignment_ok(DIR_LONG, trendD, trend4h, yosugaRequireHtfAlign)
bool htfShortOk = f_htf_alignment_ok(DIR_SHORT, trendD, trend4h, yosugaRequireHtfAlign)
bool longStructureOk = f_side_structure_ok(DIR_LONG, trend1h, recentBullReversalOk, htfLongOk)
bool shortStructureOk = f_side_structure_ok(DIR_SHORT, trend1h, recentBearReversalOk, htfShortOk)
float breakUpPrice = f_break_price(DIR_LONG, pivotRefHigh, pivotRefLow, yosugaBreakBufferTicks)
float breakDownPrice = f_break_price(DIR_SHORT, pivotRefHigh, pivotRefLow, yosugaBreakBufferTicks)
bool longBreakConfirmed = zoneLongOk and longStructureOk and f_break_confirmed(DIR_LONG, breakUpPrice)
bool shortBreakConfirmed = zoneShortOk and shortStructureOk and f_break_confirmed(DIR_SHORT, breakDownPrice)
bool longCandidateMark = longBreakConfirmed
bool shortCandidateMark = shortBreakConfirmed
int entrySignalDir = longBreakConfirmed ? DIR_LONG : shortBreakConfirmed ? DIR_SHORT : DIR_NONE

if not inTrade and entrySignalDir != DIR_NONE
    [nextTp, nextSl, canOpenTrade] = f_trade_levels(entrySignalDir, lastHighPrice, lastLowPrice)
    if canOpenTrade
        inTrade := true
        tradeDir := entrySignalDir
        entryPrice := close
        tpPrice := nextTp
        slPrice := nextSl
        entryBarIndex := bar_index
        longEntryMark := entrySignalDir == DIR_LONG
        shortEntryMark := entrySignalDir == DIR_SHORT
        activeTpLine := line.new(bar_index, tpPrice, bar_index + 1, tpPrice, xloc=xloc.bar_index, extend=extend.right, color=color.new(color.lime, 0), width=1, style=line.style_dashed)
        activeSlLine := line.new(bar_index, slPrice, bar_index + 1, slPrice, xloc=xloc.bar_index, extend=extend.right, color=color.new(color.red, 0), width=1, style=line.style_dashed)

bool canJudgeTradeResult = inTrade and not na(entryBarIndex) and bar_index > entryBarIndex
if canJudgeTradeResult
    int result = f_trade_result(tradeDir, tpPrice, slPrice)
    if result != RESULT_NONE
        array.push(closedTradeResults, result)
        if not na(activeTpLine)
            line.delete(activeTpLine)
            activeTpLine := na
        if not na(activeSlLine)
            line.delete(activeSlLine)
            activeSlLine := na
        inTrade := false
        tradeDir := DIR_NONE
        tpPrice := na
        slPrice := na
        entryPrice := na
        entryBarIndex := na

plotshape(longEntryMark, title="Long Entry", style=shape.triangleup, location=location.belowbar, color=color.new(color.lime, 0), size=size.small, text="L")
plotshape(shortEntryMark, title="Short Entry", style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.small, text="S")
float tpEntrySymbol = (longEntryMark or shortEntryMark) ? tpPrice : na
float slEntrySymbol = (longEntryMark or shortEntryMark) ? slPrice : na
plotshape(tpEntrySymbol, title="TP Symbol", style=shape.diamond, location=location.absolute, color=color.new(color.lime, 0), size=size.tiny)
plotshape(slEntrySymbol, title="SL Symbol", style=shape.xcross, location=location.absolute, color=color.new(color.red, 0), size=size.tiny)
plotshape(showEntryCandidates and longCandidateMark, title="Long Entry Candidate", style=shape.circle, location=location.belowbar, color=color.new(color.lime, 70), size=size.tiny, text="CL")
plotshape(showEntryCandidates and shortCandidateMark, title="Short Entry Candidate", style=shape.circle, location=location.abovebar, color=color.new(color.red, 70), size=size.tiny, text="CS")

// === Dow trend table (multi-timeframe) ===
int dow0 = f_dow_state_on_tf(dowTf0)
int dow1 = f_dow_state_on_tf(dowTf1)
int dow2 = f_dow_state_on_tf(dowTf2)
int dow3 = f_dow_state_on_tf(dowTf3)
int dow4 = f_dow_state_on_tf(dowTf4)

var table dowTable = table.new(position.bottom_right, 2, 6, bgcolor=color.new(color.black, 80))
if barstate.islast and showDowTrendTable
    table.cell(dowTable, 0, 0, "TF", text_color=color.white)
    table.cell(dowTable, 1, 0, "Trend", text_color=color.white)
    f_set_dow_row(dowTable, 1, dowTf0, dow0)
    f_set_dow_row(dowTable, 2, dowTf1, dow1)
    f_set_dow_row(dowTable, 3, dowTf2, dow2)
    f_set_dow_row(dowTable, 4, dowTf3, dow3)
    f_set_dow_row(dowTable, 5, dowTf4, dow4)

scenarioPos = scenarioPositionOpt == "Top Left" ? position.top_left : scenarioPositionOpt == "Top Center" ? position.top_center : scenarioPositionOpt == "Top Right" ? position.top_right : scenarioPositionOpt == "Bottom Left" ? position.bottom_left : scenarioPositionOpt == "Bottom Center" ? position.bottom_center : position.bottom_right
var table scenarioTable = table.new(scenarioPos, 1, 9, bgcolor=color.new(color.black, 80))
if barstate.islast and showScenarioTable
    string marketBias = f_bias_label(trendD, trend4h)
    string longPlan = longAligned ? (closeInEntryZoneNow ? "LONG: zone rebound setup. Trigger on bullish break." : "LONG: wait for pullback into entry zone.") : "LONG: lower priority."
    string shortPlan = shortAligned ? (closeInEntryZoneNow ? "SHORT: zone rejection setup. Trigger on bearish break." : "SHORT: wait for rally into entry zone.") : "SHORT: lower priority."
    string riskLine = longAligned and shortAligned ? "RISK: mixed signal, reduce size." : longAligned ? "RISK: invalidate below recent swing low." : shortAligned ? "RISK: invalidate above recent swing high." : "RISK: no edge, stay selective."
    string momentumLine = str.format("Momentum(1H): {0}", f_momentum_label(momentum1h))
    string yosugaGate = str.format("YosugaGate L[{0}/{1}/{2}] S[{3}/{4}/{5}]", longStructureOk ? "OK" : "NG", zoneLongOk ? "OK" : "NG", longBreakConfirmed ? "OK" : "NG", shortStructureOk ? "OK" : "NG", zoneShortOk ? "OK" : "NG", shortBreakConfirmed ? "OK" : "NG")
    table.cell(scenarioTable, 0, 0, "Scenario", text_color=color.white)
    table.cell(scenarioTable, 0, 1, str.format("Bias: {0}", marketBias), text_color=color.white)
    table.cell(scenarioTable, 0, 2, str.format("Trend D/H4/1H: {0}/{1}/{2}", f_dow_label(trendD), f_dow_label(trend4h), f_dow_label(trend1h)), text_color=color.white)
    table.cell(scenarioTable, 0, 3, momentumLine, text_color=f_momentum_color(momentum1h))
    table.cell(scenarioTable, 0, 4, yosugaGate, text_color=color.new(color.silver, 0))
    table.cell(scenarioTable, 0, 5, str.format("Zone: {0}", f_zone_label(closeInEntryZoneNow)), text_color=color.white)
    table.cell(scenarioTable, 0, 6, longPlan, text_color=color.new(color.lime, 0))
    table.cell(scenarioTable, 0, 7, shortPlan, text_color=color.new(color.red, 0))
    table.cell(scenarioTable, 0, 8, riskLine, text_color=color.new(color.yellow, 0))

// === Stats table ===
var table stats = table.new(position.top_right, 2, 3, bgcolor=color.new(color.black, 80))
if barstate.islast and showWinrate
    [wins, losses] = f_count_wins_losses(closedTradeResults)
    int total = wins + losses
    float winrate = total > 0 ? wins * 100.0 / total : na
    table.cell(stats, 0, 0, "Win Rate (Loaded Candles)", text_color=color.white)
    table.cell(stats, 1, 0, total > 0 ? str.format("{0,number,#.##}%", winrate) : "N/A", text_color=color.white)
    table.cell(stats, 0, 1, "W/L", text_color=color.white)
    table.cell(stats, 1, 1, str.format("{0}/{1}", wins, losses), text_color=color.white)
    table.cell(stats, 0, 2, "Closed Trades", text_color=color.white)
    table.cell(stats, 1, 2, str.format("{0}", total), text_color=color.white)
