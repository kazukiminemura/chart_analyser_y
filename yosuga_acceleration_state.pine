//@version=5
indicator("Yosuga Acceleration State Analyzer", shorttitle="YosugaAccel", overlay=true, max_labels_count=500, max_lines_count=500)

// === Input Configuration ===
groupSwing = "Swing Detection"
pivotLen = input.int(10, "Pivot Length", minval=1, group=groupSwing, tooltip="Pivot identifier (left/right bars) used for swing leg calculations")
holdBars = input.int(3, "Minimum Bars To Hold State", minval=0, group=groupSwing, tooltip="Prevents rapid flipping by enforcing a minimum hold duration")

groupMTF = "Trend Context"
tfTrend = input.timeframe("240", "Higher Timeframe", group=groupMTF, tooltip="Primary trend context timeframe used for Dow-style confirmation")
tfSignal = input.timeframe("", "Signal Timeframe", group=groupMTF, tooltip="Execution timeframe. Leave empty to use the chart timeframe.")
alignWeight = input.float(1.0, "MTF Alignment Weight", minval=0.0, group=groupMTF, tooltip="Weight for higher/lower timeframe trend agreement")

groupLeg = "Swing Legs"
legWeight = input.float(1.2, "Swing Leg Weight", minval=0.0, group=groupLeg, tooltip="Influence of swing leg expansion/contraction")
legSensitivity = input.float(2.5, "Swing Leg Sensitivity", minval=0.1, group=groupLeg, tooltip="How aggressively leg size changes impact the score")

groupATR = "ATR / Volatility"
atrLen = input.int(14, "ATR Length", minval=1, group=groupATR)
atrSmooth = input.int(14, "ATR Baseline Length", minval=1, group=groupATR, tooltip="Smoothing window used to gauge ATR acceleration")
atrWeight = input.float(1.0, "ATR Weight", minval=0.0, group=groupATR)
atrSensitivity = input.float(4.0, "ATR Sensitivity", minval=0.1, group=groupATR)

groupVol = "Volume"
useVolume = input.bool(true, "Use Volume Component", group=groupVol, tooltip="Turn off when the market lacks volume data")
volLen = input.int(20, "Volume SMA Length", minval=1, group=groupVol)
volWeight = input.float(0.8, "Volume Weight", minval=0.0, group=groupVol)
volSensitivity = input.float(3.0, "Volume Sensitivity", minval=0.1, group=groupVol)

groupPA = "Price Action"
emaFast = input.int(12, "Fast EMA", minval=1, group=groupPA)
emaSlow = input.int(26, "Slow EMA", minval=2, group=groupPA)
priceActionWeight = input.float(1.0, "Price Action Weight", minval=0.0, group=groupPA)
priceActionSensitivity = input.float(2.0, "Price Action Sensitivity", minval=0.1, group=groupPA)

groupThresholds = "Scoring Thresholds"
accelThreshold = input.float(2.5, "ACCEL Threshold", minval=0.1, group=groupThresholds)
decelThreshold = input.float(2.5, "DECEL Threshold", minval=0.1, group=groupThresholds)
neutralBand = input.float(0.2, "Neutral Deadband", minval=0.0, group=groupThresholds, tooltip="Keeps the state neutral when score is near zero")

groupHiLoLines = "High/Low Lines"
showHiLoLines = input.bool(true, "Show High/Low Lines", group=groupHiLoLines, tooltip="Draw horizontal lines at each detected swing high/low")
hiLineColor = input.color(color.aqua, "High Line Color", group=groupHiLoLines)
lowLineColor = input.color(color.aqua, "Low Line Color", group=groupHiLoLines)
hiLoLineWidth = input.int(2, "Line Width", minval=1, maxval=4, group=groupHiLoLines)
hiLoExtendRight = input.bool(true, "Extend Lines Right", group=groupHiLoLines)
hiLoMaxLines = input.int(20, "Max Historical Lines Per Side", minval=1, maxval=500, group=groupHiLoLines, tooltip="Limits stored swing lines to avoid exceeding TradingView line limits")

groupScenario = "Scenario Builder"
showScenario = input.bool(true, "Show Scenario Arrows", group=groupScenario, tooltip="Display entry arrows when state flips and annotate take-profit targets")
scenarioTpAtr = input.float(1.5, "Take Profit ATR Multiple", minval=0.1, step=0.1, group=groupScenario)
scenarioArrowOffsetAtr = input.float(0.5, "Arrow Offset (ATR)", minval=0.0, step=0.1, group=groupScenario)
scenarioLongColor = input.color(color.lime, "Long Arrow Color", group=groupScenario)
scenarioShortColor = input.color(color.fuchsia, "Short Arrow Color", group=groupScenario)
scenarioLabelBg = input.color(color.new(color.black, 60), "Scenario Label Background", group=groupScenario)
scenarioMaxSignals = input.int(20, "Max Scenario Marks", minval=1, maxval=100, group=groupScenario, tooltip="Limits number of scenario arrows/labels kept on chart")
scenarioArrowForwardBars = input.int(5, "Arrow Projection Bars", minval=1, maxval=100, group=groupScenario, tooltip="Number of bars used to project the scenario arrow forward")

groupDisplay = "Display"
showStateText = input.bool(true, "Show Japanese State Text", group=groupDisplay, tooltip="Plots \u52A0\u901F\u4E2D/\u6E1B\u901F\u4E2D/\u4E2D\u7ACB near price")
stateTextOffsetATR = input.float(1.0, "State Text Offset (ATR)", minval=0.0, group=groupDisplay, tooltip="Vertical offset in ATR multiples for the state label")

// === Helper Types & Functions ===
type SwingState
    float lastPivotPrice = na
    bool lastWasHigh = false
    float currLeg = na
    float prevLeg = na
    float lastHigh = na
    float prevHigh = na
    float lastLow = na
    float prevLow = na
    int trend = 0

f_newSwingState() =>
    SwingState.new()

f_updateSwingState(SwingState state, float pivotHigh, float pivotLow) =>
    if not na(pivotHigh)
        if not state.lastWasHigh and not na(state.lastPivotPrice)
            state.prevLeg := state.currLeg
            state.currLeg := math.abs(pivotHigh - state.lastPivotPrice)
        state.prevHigh := state.lastHigh
        state.lastHigh := pivotHigh
        state.lastPivotPrice := pivotHigh
        state.lastWasHigh := true
    if not na(pivotLow)
        if state.lastWasHigh and not na(state.lastPivotPrice)
            state.prevLeg := state.currLeg
            state.currLeg := math.abs(state.lastPivotPrice - pivotLow)
        state.prevLow := state.lastLow
        state.lastLow := pivotLow
        state.lastPivotPrice := pivotLow
        state.lastWasHigh := false
    if not na(state.lastHigh) and not na(state.prevHigh) and not na(state.lastLow) and not na(state.prevLow)
        bool higherHigh = state.lastHigh > state.prevHigh
        bool higherLow = state.lastLow > state.prevLow
        bool lowerHigh = state.lastHigh < state.prevHigh
        bool lowerLow = state.lastLow < state.prevLow
        state.trend := higherHigh and higherLow ? 1 : lowerHigh and lowerLow ? -1 : 0
    state

f_newPivot(series float pivot) =>
    not na(pivot) and (na(pivot[1]) or pivot != pivot[1]) ? pivot : na

f_series(string tf, series float source) =>
    tf == "" ? source : request.security(syminfo.tickerid, tf, source, lookahead=barmerge.lookahead_off)

f_tanh(float x) =>
    // Clamp input to avoid overflow in exp
    float clamped = math.max(math.min(x, 30.0), -30.0)
    float e2x = math.exp(2.0 * clamped)
    (e2x - 1.0) / (e2x + 1.0)

const int SCENARIO_LINE_WIDTH = 2

// Scenario bookkeeping keeps related lines/labels together for easier updates
type Scenario
    int direction = 0
    int entryBar = na
    float entryPrice = na
    int targetBar = na
    float targetPrice = na
    bool pullbackPlotted = false
    float pullbackPrice = na
    line legEntry = na
    line legTarget = na
    label entryLabel = na
    label targetLabel = na
    label pullbackLabel = na

f_scenarioCreate(int direction, int entryBar, float entryPrice, int midIndex, float midPrice, int targetBar, float targetPrice, float entryLabelPrice, string entryText, entryStyle, color arrowColor, color labelBg) =>
    line leg1 = line.new(entryBar, entryPrice, midIndex, midPrice, xloc=xloc.bar_index, extend=extend.none, color=arrowColor, width=SCENARIO_LINE_WIDTH)
    line leg2 = line.new(midIndex, midPrice, targetBar, targetPrice, xloc=xloc.bar_index, extend=extend.none, color=arrowColor, width=SCENARIO_LINE_WIDTH)
    label entryLabel = label.new(entryBar, entryLabelPrice, entryText, xloc=xloc.bar_index, yloc=yloc.price, color=labelBg, textcolor=color.white, style=entryStyle)
    label targetLabel = label.new(targetBar, targetPrice, "利確目標: " + str.tostring(targetPrice, format.mintick), xloc=xloc.bar_index, yloc=yloc.price, color=labelBg, textcolor=color.white, style=label.style_label_left)
    Scenario scenario = Scenario.new()
    scenario.direction := direction
    scenario.entryBar := entryBar
    scenario.entryPrice := entryPrice
    scenario.targetBar := targetBar
    scenario.targetPrice := targetPrice
    scenario.legEntry := leg1
    scenario.legTarget := leg2
    scenario.entryLabel := entryLabel
    scenario.targetLabel := targetLabel
    scenario.pullbackPlotted := false
    scenario.pullbackLabel := na
    scenario.pullbackPrice := na
    scenario

f_scenarioUpdatePullback(Scenario scenario, int pullbackBar, float pullbackPrice, float pullbackLabelPrice, string pullbackText, pullbackStyle, color labelColor) =>
    int pullbackDistance = pullbackBar - scenario.entryBar
    if pullbackDistance < 1
        pullbackDistance := 1
    scenario.targetBar := pullbackBar + pullbackDistance
    if not na(scenario.legEntry)
        line.set_xy1(scenario.legEntry, scenario.entryBar, scenario.entryPrice)
        line.set_xy2(scenario.legEntry, pullbackBar, pullbackPrice)
    if not na(scenario.legTarget)
        line.set_xy1(scenario.legTarget, pullbackBar, pullbackPrice)
        line.set_xy2(scenario.legTarget, scenario.targetBar, scenario.targetPrice)
    if not na(scenario.targetLabel)
        label.set_xy(scenario.targetLabel, scenario.targetBar, scenario.targetPrice)
        label.set_text(scenario.targetLabel, "利確目標: " + str.tostring(scenario.targetPrice, format.mintick))
    if not na(scenario.pullbackLabel)
        label.delete(scenario.pullbackLabel)
    scenario.pullbackLabel := label.new(pullbackBar, pullbackLabelPrice, pullbackText, xloc=xloc.bar_index, yloc=yloc.price, color=labelColor, textcolor=color.white, style=pullbackStyle)
    scenario.pullbackPrice := pullbackPrice
    scenario.pullbackPlotted := true
    scenario

f_scenarioDispose(Scenario scenario) =>
    if not na(scenario.legEntry)
        line.delete(scenario.legEntry)
    if not na(scenario.legTarget)
        line.delete(scenario.legTarget)
    if not na(scenario.entryLabel)
        label.delete(scenario.entryLabel)
    if not na(scenario.targetLabel)
        label.delete(scenario.targetLabel)
    if not na(scenario.pullbackLabel)
        label.delete(scenario.pullbackLabel)

f_scenarioTrim(array<Scenario> scenarioArr, int maxSignals) =>
    int extra = array.size(scenarioArr) - maxSignals
    if extra > 0
        for _ = 0 to extra - 1
            Scenario removed = array.shift(scenarioArr)
            f_scenarioDispose(removed)

f_scenarioClear(array<Scenario> scenarioArr) =>
    int count = array.size(scenarioArr)
    if count > 0
        for i = 0 to count - 1
            Scenario scenario = array.get(scenarioArr, i)
            f_scenarioDispose(scenario)
    array.clear(scenarioArr)

// === Series Acquisition ===
signalClose = f_series(tfSignal, close)
signalVolume = f_series(tfSignal, volume)

signalPivotHighRaw = tfSignal == "" ? ta.pivothigh(high, pivotLen, pivotLen) : request.security(syminfo.tickerid, tfSignal, ta.pivothigh(high, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)
signalPivotLowRaw = tfSignal == "" ? ta.pivotlow(low, pivotLen, pivotLen) : request.security(syminfo.tickerid, tfSignal, ta.pivotlow(low, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)

trendPivotHighRaw = tfTrend == "" ? signalPivotHighRaw : request.security(syminfo.tickerid, tfTrend, ta.pivothigh(high, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)
trendPivotLowRaw = tfTrend == "" ? signalPivotLowRaw : request.security(syminfo.tickerid, tfTrend, ta.pivotlow(low, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)

// === Swing State Updates ===
var SwingState signalState = f_newSwingState()
var SwingState trendState = f_newSwingState()
var line[] highLines = array.new_line()
var line[] lowLines = array.new_line()
var label stateTextLabel = na
var Scenario[] scenarios = array.new<Scenario>()

signalPivotHigh = f_newPivot(signalPivotHighRaw)
signalPivotLow = f_newPivot(signalPivotLowRaw)
trendPivotHigh = f_newPivot(trendPivotHighRaw)
trendPivotLow = f_newPivot(trendPivotLowRaw)

signalState := f_updateSwingState(signalState, signalPivotHigh, signalPivotLow)
trendState := f_updateSwingState(trendState, trendPivotHigh, trendPivotLow)

if showHiLoLines
    if not na(signalPivotHigh)
        line newHighLine = line.new(bar_index - pivotLen, signalPivotHigh, bar_index, signalPivotHigh, xloc=xloc.bar_index, extend=hiLoExtendRight ? extend.right : extend.none, color=hiLineColor, width=hiLoLineWidth)
        array.push(highLines, newHighLine)
        line.set_style(newHighLine, line.style_dotted)
        if array.size(highLines) > hiLoMaxLines
            line.delete(array.shift(highLines))

    if not na(signalPivotLow)
        line newLowLine = line.new(bar_index - pivotLen, signalPivotLow, bar_index, signalPivotLow, xloc=xloc.bar_index, extend=hiLoExtendRight ? extend.right : extend.none, color=lowLineColor, width=hiLoLineWidth)
        array.push(lowLines, newLowLine)
        line.set_style(newLowLine, line.style_dotted)
        if array.size(lowLines) > hiLoMaxLines
            line.delete(array.shift(lowLines))

    int highCount = array.size(highLines)
    if highCount > 0
        for i = 0 to highCount - 1
            line existingHighLine = array.get(highLines, i)
            line.set_extend(existingHighLine, hiLoExtendRight ? extend.right : extend.none)
            line.set_color(existingHighLine, hiLineColor)
            line.set_width(existingHighLine, hiLoLineWidth)
            line.set_style(existingHighLine, line.style_dotted)

    int lowCount = array.size(lowLines)
    if lowCount > 0
        for i = 0 to lowCount - 1
            line existingLowLine = array.get(lowLines, i)
            line.set_extend(existingLowLine, hiLoExtendRight ? extend.right : extend.none)
            line.set_color(existingLowLine, lowLineColor)
            line.set_width(existingLowLine, hiLoLineWidth)
            line.set_style(existingLowLine, line.style_dotted)
else
    int highCount = array.size(highLines)
    if highCount > 0
        for i = 0 to highCount - 1
            line.delete(array.get(highLines, i))
    array.clear(highLines)
    int lowCount = array.size(lowLines)
    if lowCount > 0
        for i = 0 to lowCount - 1
            line.delete(array.get(lowLines, i))
    array.clear(lowLines)

// === Direction Resolution ===
float derivedDir = signalState.trend != 0 ? signalState.trend : trendState.trend != 0 ? trendState.trend : math.sign(ta.ema(signalClose, emaFast) - ta.ema(signalClose, emaSlow))
float baseDir = derivedDir > 0 ? 1.0 : derivedDir < 0 ? -1.0 : 0.0

// === Component Calculations ===
legRatio = na(signalState.currLeg) or na(signalState.prevLeg) or signalState.prevLeg == 0.0 ? na : signalState.currLeg / signalState.prevLeg
legComponent = na(legRatio) or baseDir == 0.0 ? 0.0 : legWeight * f_tanh((legRatio - 1.0) * legSensitivity) * baseDir

signalATR = tfSignal == "" ? ta.atr(atrLen) : request.security(syminfo.tickerid, tfSignal, ta.atr(atrLen), lookahead=barmerge.lookahead_off)
atrBaseline = ta.sma(signalATR, atrSmooth)
atrDelta = na(atrBaseline) or atrBaseline == 0.0 ? 0.0 : (signalATR / atrBaseline) - 1.0
atrComponent = baseDir == 0.0 ? 0.0 : atrWeight * f_tanh(atrDelta * atrSensitivity) * baseDir

volBaseline = ta.sma(signalVolume, volLen)
highestVol = ta.highest(signalVolume, volLen)
lowestVol = ta.lowest(signalVolume, volLen)
bool volumeUsable = useVolume and not na(signalVolume) and not na(highestVol) and not na(lowestVol) and highestVol != lowestVol
volDelta = na(volBaseline) or volBaseline == 0.0 ? 0.0 : (signalVolume / volBaseline) - 1.0
volComponent = volumeUsable and baseDir != 0.0 ? volWeight * f_tanh(volDelta * volSensitivity) * baseDir : 0.0

emaFastSeries = ta.ema(signalClose, emaFast)
emaSlowSeries = ta.ema(signalClose, emaSlow)
priceActionNorm = signalATR == 0.0 ? emaFastSeries - emaSlowSeries : (emaFastSeries - emaSlowSeries) / signalATR
priceActionComponent = priceActionWeight * f_tanh(priceActionNorm * priceActionSensitivity) * (baseDir == 0.0 ? math.sign(priceActionNorm) : baseDir)

trendDir = trendState.trend
signalDir = signalState.trend
alignComponent = alignWeight * (trendDir == 0 or baseDir == 0.0 ? 0.0 : trendDir == baseDir ? 1.0 : -1.0)

score = legComponent + atrComponent + volComponent + priceActionComponent + alignComponent

// === State Machine ===
var string stateLabel = "NEUTRAL"
var int stateBarIndex = bar_index

string desiredState = "NEUTRAL"
if score >= accelThreshold
    desiredState := "ACCEL"
else if score <= -decelThreshold
    desiredState := "DECEL"
else if math.abs(score) <= neutralBand
    desiredState := "NEUTRAL"
else
    desiredState := stateLabel

bool allowSwitch = desiredState == stateLabel or bar_index - stateBarIndex >= holdBars or desiredState == "NEUTRAL"

if desiredState != stateLabel and allowSwitch
    stateLabel := desiredState
    stateBarIndex := bar_index

// === Confidence & Diagnostics ===
maxThreshold = math.max(accelThreshold, decelThreshold)
confidence = maxThreshold == 0.0 ? 0.0 : math.min(math.abs(score) / maxThreshold, 1.0)
confidencePct = math.round(confidence * 100.0)

color stateColor = stateLabel == "ACCEL" ? color.new(color.teal, 0) : stateLabel == "DECEL" ? color.new(color.red, 0) : color.new(color.gray, 30)

if showStateText
    string jpState = stateLabel == "ACCEL" ? "\u52A0\u901F\u4E2D" : stateLabel == "DECEL" ? "\u6E1B\u901F\u4E2D" : "\u4E2D\u7ACB"
    color jpTextColor = stateLabel == "ACCEL" ? color.teal : stateLabel == "DECEL" ? color.red : color.gray
    float atrForLabel = nz(signalATR, ta.atr(atrLen))
    float offsetValue = stateTextOffsetATR * atrForLabel
    float anchorPrice = signalClose
    if stateLabel == "ACCEL"
        anchorPrice += offsetValue
    else if stateLabel == "DECEL"
        anchorPrice -= offsetValue
    if na(stateTextLabel)
        stateTextLabel := label.new(bar_index, anchorPrice, jpState, xloc=xloc.bar_index, textcolor=jpTextColor, style=label.style_label_left, color=color.new(stateColor, 70))
    else
        label.set_xy(stateTextLabel, bar_index, anchorPrice)
        label.set_text(stateTextLabel, jpState)
        label.set_textcolor(stateTextLabel, jpTextColor)
        label.set_color(stateTextLabel, color.new(stateColor, 70))
else if not na(stateTextLabel)
    label.delete(stateTextLabel)
    stateTextLabel := na

bgcolor(color.new(stateColor, 85), title="State Background")

plotchar(stateLabel == "ACCEL", "ACCEL Flag", "A", location.top, color=color.teal, size=size.tiny)

// === Scenario Visualization ===
bool longTrigger = showScenario and stateLabel == "ACCEL" and stateLabel[1] != "ACCEL"
bool shortTrigger = showScenario and stateLabel == "DECEL" and stateLabel[1] != "DECEL"
float scenarioAtr = nz(signalATR, ta.atr(atrLen))
float arrowOffset = scenarioArrowOffsetAtr * scenarioAtr
float swingSize = na(signalState.currLeg) or signalState.currLeg <= 0 ? scenarioAtr * scenarioTpAtr : signalState.currLeg
int baseProjection = scenarioArrowForwardBars < 2 ? 2 : scenarioArrowForwardBars
float dynamicProjection = scenarioAtr == 0.0 ? baseProjection : math.abs(swingSize) / scenarioAtr
int scenarioBars = int(math.round(dynamicProjection))
if scenarioBars < baseProjection
    scenarioBars := baseProjection
int midOffset = int(math.round(math.max(1.0, scenarioBars * 0.5)))
if midOffset >= scenarioBars
    midOffset := scenarioBars - 1
int midIndex = bar_index + midOffset
if longTrigger
    float entryPriceLong = close
    float targetPriceLong = entryPriceLong + swingSize
    int targetIndexLong = bar_index + scenarioBars
    float offsetLong = arrowOffset > 0.0 ? arrowOffset : math.max(0.0001, math.abs(swingSize) * 0.25)
    float midPriceLong = entryPriceLong + offsetLong
    float entryLabelPriceLong = entryPriceLong - offsetLong
    Scenario longScenario = f_scenarioCreate(1, bar_index, entryPriceLong, midIndex, midPriceLong, targetIndexLong, targetPriceLong, entryLabelPriceLong, "成立条件: ACCEL転換", label.style_arrowup, scenarioLongColor, scenarioLabelBg)
    array.push(scenarios, longScenario)

if shortTrigger
    float entryPriceShort = close
    float targetPriceShort = entryPriceShort - swingSize
    int targetIndexShort = bar_index + scenarioBars
    float offsetShort = arrowOffset > 0.0 ? arrowOffset : math.max(0.0001, math.abs(swingSize) * 0.25)
    float midPriceShort = entryPriceShort - offsetShort
    float entryLabelPriceShort = entryPriceShort + offsetShort
    Scenario shortScenario = f_scenarioCreate(-1, bar_index, entryPriceShort, midIndex, midPriceShort, targetIndexShort, targetPriceShort, entryLabelPriceShort, "成立条件: DECEL転換", label.style_arrowdown, scenarioShortColor, scenarioLabelBg)
    array.push(scenarios, shortScenario)

if showScenario
    float pullbackOffset = arrowOffset > 0.0 ? arrowOffset : math.max(0.0001, scenarioAtr * 0.25)
    int scenarioCount = array.size(scenarios)
    if scenarioCount > 0
        if not na(signalPivotLow)
            int pullbackBarLong = bar_index - pivotLen
            float pullbackPriceLong = signalPivotLow
            for idx = 0 to scenarioCount - 1
                Scenario scenario = array.get(scenarios, idx)
                if scenario.direction == 1 and not scenario.pullbackPlotted and pullbackBarLong > scenario.entryBar
                    float labelPriceLong = pullbackPriceLong - pullbackOffset
                    scenario := f_scenarioUpdatePullback(scenario, pullbackBarLong, pullbackPriceLong, labelPriceLong, "押し目", label.style_arrowup, scenarioLongColor)
                    array.set(scenarios, idx, scenario)
                    break
        if not na(signalPivotHigh)
            int pullbackBarShort = bar_index - pivotLen
            float pullbackPriceShort = signalPivotHigh
            for idx = 0 to scenarioCount - 1
                Scenario scenario = array.get(scenarios, idx)
                if scenario.direction == -1 and not scenario.pullbackPlotted and pullbackBarShort > scenario.entryBar
                    float labelPriceShort = pullbackPriceShort + pullbackOffset
                    scenario := f_scenarioUpdatePullback(scenario, pullbackBarShort, pullbackPriceShort, labelPriceShort, "戻り売り", label.style_arrowdown, scenarioShortColor)
                    array.set(scenarios, idx, scenario)
                    break

if longTrigger or shortTrigger
    f_scenarioTrim(scenarios, scenarioMaxSignals)

if not showScenario
    f_scenarioClear(scenarios)

plotchar(stateLabel == "DECEL", "DECEL Flag", "D", location.bottom, color=color.red, size=size.tiny)

// === Table Output ===
var table infoTable = table.new(position.top_right, 1, 6, border_width=1)
if barstate.islast
    string headerText = "State: " + stateLabel + " (" + str.tostring(confidencePct, format.mintick) + "%)"
    table.cell(infoTable, 0, 0, headerText, text_color=color.white, bgcolor=color.new(stateColor, 60))
    table.cell(infoTable, 0, 1, "Score " + str.tostring(score, format.mintick), text_color=color.white)
    table.cell(infoTable, 0, 2, "Leg " + str.tostring(legComponent, format.mintick) + " | ATR " + str.tostring(atrComponent, format.mintick), text_color=color.white)
    table.cell(infoTable, 0, 3, "Vol " + str.tostring(volComponent, format.mintick) + " | PA " + str.tostring(priceActionComponent, format.mintick), text_color=color.white)
    table.cell(infoTable, 0, 4, "Align " + str.tostring(alignComponent, format.mintick) + " | Dir " + str.tostring(baseDir, format.mintick), text_color=color.white)
    table.cell(infoTable, 0, 5, "TrendHTF " + str.tostring(trendDir, format.mintick) + " | TrendLTF " + str.tostring(signalDir, format.mintick), text_color=color.white)

// === Alerts ===
alertcondition(stateLabel == "ACCEL" and stateLabel[1] != "ACCEL", "State: ACCEL", "Acceleration detected on {{ticker}} @ {{interval}}")
alertcondition(stateLabel == "DECEL" and stateLabel[1] != "DECEL", "State: DECEL", "Deceleration detected on {{ticker}} @ {{interval}}")
alertcondition(stateLabel == "NEUTRAL" and stateLabel[1] != "NEUTRAL", "State: NEUTRAL", "Neutral state on {{ticker}} @ {{interval}}")




