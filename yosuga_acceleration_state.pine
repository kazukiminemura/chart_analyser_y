//@version=5
indicator("Yosuga Acceleration State Analyzer", shorttitle="YosugaAccel", overlay=true, max_labels_count=500, max_lines_count=500)

// === Input Configuration ===
groupSwing = "Swing Detection"
pivotLen = input.int(5, "Pivot Length", minval=1, group=groupSwing, tooltip="Pivot identifier (left/right bars) used for swing leg calculations")
holdBars = input.int(3, "Minimum Bars To Hold State", minval=0, group=groupSwing, tooltip="Prevents rapid flipping by enforcing a minimum hold duration")

groupMTF = "Trend Context"
tfTrend = input.timeframe("240", "Higher Timeframe", group=groupMTF, tooltip="Primary trend context timeframe used for Dow-style confirmation")
tfSignal = input.timeframe("", "Signal Timeframe", group=groupMTF, tooltip="Execution timeframe. Leave empty to use the chart timeframe.")
alignWeight = input.float(1.0, "MTF Alignment Weight", minval=0.0, group=groupMTF, tooltip="Weight for higher/lower timeframe trend agreement")

groupLeg = "Swing Legs"
legWeight = input.float(1.2, "Swing Leg Weight", minval=0.0, group=groupLeg, tooltip="Influence of swing leg expansion/contraction")
legSensitivity = input.float(2.5, "Swing Leg Sensitivity", minval=0.1, group=groupLeg, tooltip="How aggressively leg size changes impact the score")

groupATR = "ATR / Volatility"
atrLen = input.int(14, "ATR Length", minval=1, group=groupATR)
atrSmooth = input.int(14, "ATR Baseline Length", minval=1, group=groupATR, tooltip="Smoothing window used to gauge ATR acceleration")
atrWeight = input.float(1.0, "ATR Weight", minval=0.0, group=groupATR)
atrSensitivity = input.float(4.0, "ATR Sensitivity", minval=0.1, group=groupATR)

groupVol = "Volume"
useVolume = input.bool(true, "Use Volume Component", group=groupVol, tooltip="Turn off when the market lacks volume data")
volLen = input.int(20, "Volume SMA Length", minval=1, group=groupVol)
volWeight = input.float(0.8, "Volume Weight", minval=0.0, group=groupVol)
volSensitivity = input.float(3.0, "Volume Sensitivity", minval=0.1, group=groupVol)

groupPA = "Price Action"
emaFast = input.int(12, "Fast EMA", minval=1, group=groupPA)
emaSlow = input.int(26, "Slow EMA", minval=2, group=groupPA)
priceActionWeight = input.float(1.0, "Price Action Weight", minval=0.0, group=groupPA)
priceActionSensitivity = input.float(2.0, "Price Action Sensitivity", minval=0.1, group=groupPA)

groupThresholds = "Scoring Thresholds"
accelThreshold = input.float(2.5, "ACCEL Threshold", minval=0.1, group=groupThresholds)
decelThreshold = input.float(2.5, "DECEL Threshold", minval=0.1, group=groupThresholds)
neutralBand = input.float(0.2, "Neutral Deadband", minval=0.0, group=groupThresholds, tooltip="Keeps the state neutral when score is near zero")

groupAutoLines = "Auto Swing Lines"
showAutoLines = input.bool(true, "Show Auto Swing Lines", group=groupAutoLines, tooltip="Draw swing-derived lines that react to scale changes")
autoLineWidth = input.int(2, "Auto Line Width", minval=1, maxval=4, group=groupAutoLines)
autoExtendRight = input.bool(true, "Extend Auto Lines Right", group=groupAutoLines)
autoHighColor = input.color(color.orange, "High Line Color", group=groupAutoLines)
autoLowColor = input.color(color.aqua, "Low Line Color", group=groupAutoLines)

groupDisplay = "Display"
showStateText = input.bool(true, "Show Japanese State Text", group=groupDisplay, tooltip="Plots \u52A0\u901F\u4E2D/\u6E1B\u901F\u4E2D/\u4E2D\u7ACB near price")
stateTextOffsetATR = input.float(1.0, "State Text Offset (ATR)", minval=0.0, group=groupDisplay, tooltip="Vertical offset in ATR multiples for the state label")

// === Helper Types & Functions ===
type SwingState
    float lastPivotPrice = na
    bool lastWasHigh = false
    float currLeg = na
    float prevLeg = na
    float lastHigh = na
    float prevHigh = na
    float lastLow = na
    float prevLow = na
    int trend = 0

f_newSwingState() =>
    SwingState.new()

f_updateSwingState(SwingState state, float pivotHigh, float pivotLow) =>
    if not na(pivotHigh)
        if not state.lastWasHigh and not na(state.lastPivotPrice)
            state.prevLeg := state.currLeg
            state.currLeg := math.abs(pivotHigh - state.lastPivotPrice)
        state.prevHigh := state.lastHigh
        state.lastHigh := pivotHigh
        state.lastPivotPrice := pivotHigh
        state.lastWasHigh := true
    if not na(pivotLow)
        if state.lastWasHigh and not na(state.lastPivotPrice)
            state.prevLeg := state.currLeg
            state.currLeg := math.abs(state.lastPivotPrice - pivotLow)
        state.prevLow := state.lastLow
        state.lastLow := pivotLow
        state.lastPivotPrice := pivotLow
        state.lastWasHigh := false
    if not na(state.lastHigh) and not na(state.prevHigh) and not na(state.lastLow) and not na(state.prevLow)
        bool higherHigh = state.lastHigh > state.prevHigh
        bool higherLow = state.lastLow > state.prevLow
        bool lowerHigh = state.lastHigh < state.prevHigh
        bool lowerLow = state.lastLow < state.prevLow
        state.trend := higherHigh and higherLow ? 1 : lowerHigh and lowerLow ? -1 : 0
    state

f_newPivot(series float pivot) =>
    not na(pivot) and (na(pivot[1]) or pivot != pivot[1]) ? pivot : na

f_series(string tf, series float source) =>
    tf == "" ? source : request.security(syminfo.tickerid, tf, source, lookahead=barmerge.lookahead_off)

f_series_int(string tf, series int source) =>
    tf == "" ? source : request.security(syminfo.tickerid, tf, source, lookahead=barmerge.lookahead_off)

f_tanh(float x) =>
    // Clamp input to avoid overflow in exp
    float clamped = math.max(math.min(x, 30.0), -30.0)
    float e2x = math.exp(2.0 * clamped)
    (e2x - 1.0) / (e2x + 1.0)

// === Series Acquisition ===
signalClose = f_series(tfSignal, close)
signalVolume = f_series(tfSignal, volume)
signalTime = f_series_int(tfSignal, time)

signalPivotHighRaw = tfSignal == "" ? ta.pivothigh(high, pivotLen, pivotLen) : request.security(syminfo.tickerid, tfSignal, ta.pivothigh(high, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)
signalPivotLowRaw = tfSignal == "" ? ta.pivotlow(low, pivotLen, pivotLen) : request.security(syminfo.tickerid, tfSignal, ta.pivotlow(low, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)

trendPivotHighRaw = tfTrend == "" ? signalPivotHighRaw : request.security(syminfo.tickerid, tfTrend, ta.pivothigh(high, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)
trendPivotLowRaw = tfTrend == "" ? signalPivotLowRaw : request.security(syminfo.tickerid, tfTrend, ta.pivotlow(low, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)

// === Swing State Updates ===
var SwingState signalState = f_newSwingState()
var SwingState trendState = f_newSwingState()
var line swingHighLine = na
var line swingLowLine = na
var float lastAutoHighValue = na
var float prevAutoHighValue = na
var float lastAutoLowValue = na
var float prevAutoLowValue = na
var float lastAutoHighIndex = na
var float prevAutoHighIndex = na
var float lastAutoLowIndex = na
var float prevAutoLowIndex = na
var int lastAutoHighTime = na
var int prevAutoHighTime = na
var int lastAutoLowTime = na
var int prevAutoLowTime = na
var label stateTextLabel = na

signalPivotHigh = f_newPivot(signalPivotHighRaw)
signalPivotLow = f_newPivot(signalPivotLowRaw)
trendPivotHigh = f_newPivot(trendPivotHighRaw)
trendPivotLow = f_newPivot(trendPivotLowRaw)

signalState := f_updateSwingState(signalState, signalPivotHigh, signalPivotLow)
trendState := f_updateSwingState(trendState, trendPivotHigh, trendPivotLow)

if not na(signalPivotHigh)
    prevAutoHighValue := lastAutoHighValue
    prevAutoHighIndex := lastAutoHighIndex
    prevAutoHighTime := lastAutoHighTime
    lastAutoHighValue := signalPivotHigh
    lastAutoHighIndex := float(bar_index - pivotLen)
    lastAutoHighTime := signalTime[pivotLen]

if not na(signalPivotLow)
    prevAutoLowValue := lastAutoLowValue
    prevAutoLowIndex := lastAutoLowIndex
    prevAutoLowTime := lastAutoLowTime
    lastAutoLowValue := signalPivotLow
    lastAutoLowIndex := float(bar_index - pivotLen)
    lastAutoLowTime := signalTime[pivotLen]

bool canDrawHighLine = showAutoLines and not na(prevAutoHighValue) and not na(lastAutoHighValue) and not na(prevAutoHighIndex) and not na(lastAutoHighIndex) and not na(prevAutoHighTime) and not na(lastAutoHighTime)
bool canDrawLowLine = showAutoLines and not na(prevAutoLowValue) and not na(lastAutoLowValue) and not na(prevAutoLowIndex) and not na(lastAutoLowIndex) and not na(prevAutoLowTime) and not na(lastAutoLowTime)

if not showAutoLines
    if not na(swingHighLine)
        line.delete(swingHighLine)
        swingHighLine := na
    if not na(swingLowLine)
        line.delete(swingLowLine)
        swingLowLine := na
else
    if canDrawHighLine
        if na(swingHighLine)
            swingHighLine := line.new(prevAutoHighTime, prevAutoHighValue, lastAutoHighTime, lastAutoHighValue, xloc=xloc.bar_time, extend=autoExtendRight ? extend.right : extend.none, color=autoHighColor, width=autoLineWidth)
        else
            line.set_xy1(swingHighLine, prevAutoHighTime, prevAutoHighValue)
            line.set_xy2(swingHighLine, lastAutoHighTime, lastAutoHighValue)
            line.set_extend(swingHighLine, autoExtendRight ? extend.right : extend.none)
            line.set_color(swingHighLine, autoHighColor)
            line.set_width(swingHighLine, autoLineWidth)
    else if not na(swingHighLine)
        line.delete(swingHighLine)
        swingHighLine := na

    if canDrawLowLine
        if na(swingLowLine)
            swingLowLine := line.new(prevAutoLowTime, prevAutoLowValue, lastAutoLowTime, lastAutoLowValue, xloc=xloc.bar_time, extend=autoExtendRight ? extend.right : extend.none, color=autoLowColor, width=autoLineWidth)
        else
            line.set_xy1(swingLowLine, prevAutoLowTime, prevAutoLowValue)
            line.set_xy2(swingLowLine, lastAutoLowTime, lastAutoLowValue)
            line.set_extend(swingLowLine, autoExtendRight ? extend.right : extend.none)
            line.set_color(swingLowLine, autoLowColor)
            line.set_width(swingLowLine, autoLineWidth)
    else if not na(swingLowLine)
        line.delete(swingLowLine)
        swingLowLine := na

// === Direction Resolution ===
float derivedDir = signalState.trend != 0 ? signalState.trend : trendState.trend != 0 ? trendState.trend : math.sign(ta.ema(signalClose, emaFast) - ta.ema(signalClose, emaSlow))
float baseDir = derivedDir > 0 ? 1.0 : derivedDir < 0 ? -1.0 : 0.0

// === Component Calculations ===
legRatio = na(signalState.currLeg) or na(signalState.prevLeg) or signalState.prevLeg == 0.0 ? na : signalState.currLeg / signalState.prevLeg
legComponent = na(legRatio) or baseDir == 0.0 ? 0.0 : legWeight * f_tanh((legRatio - 1.0) * legSensitivity) * baseDir

signalATR = tfSignal == "" ? ta.atr(atrLen) : request.security(syminfo.tickerid, tfSignal, ta.atr(atrLen), lookahead=barmerge.lookahead_off)
atrBaseline = ta.sma(signalATR, atrSmooth)
atrDelta = na(atrBaseline) or atrBaseline == 0.0 ? 0.0 : (signalATR / atrBaseline) - 1.0
atrComponent = baseDir == 0.0 ? 0.0 : atrWeight * f_tanh(atrDelta * atrSensitivity) * baseDir

volBaseline = ta.sma(signalVolume, volLen)
highestVol = ta.highest(signalVolume, volLen)
lowestVol = ta.lowest(signalVolume, volLen)
bool volumeUsable = useVolume and not na(signalVolume) and not na(highestVol) and not na(lowestVol) and highestVol != lowestVol
volDelta = na(volBaseline) or volBaseline == 0.0 ? 0.0 : (signalVolume / volBaseline) - 1.0
volComponent = volumeUsable and baseDir != 0.0 ? volWeight * f_tanh(volDelta * volSensitivity) * baseDir : 0.0

emaFastSeries = ta.ema(signalClose, emaFast)
emaSlowSeries = ta.ema(signalClose, emaSlow)
priceActionNorm = signalATR == 0.0 ? emaFastSeries - emaSlowSeries : (emaFastSeries - emaSlowSeries) / signalATR
priceActionComponent = priceActionWeight * f_tanh(priceActionNorm * priceActionSensitivity) * (baseDir == 0.0 ? math.sign(priceActionNorm) : baseDir)

trendDir = trendState.trend
signalDir = signalState.trend
alignComponent = alignWeight * (trendDir == 0 or baseDir == 0.0 ? 0.0 : trendDir == baseDir ? 1.0 : -1.0)

score = legComponent + atrComponent + volComponent + priceActionComponent + alignComponent

// === State Machine ===
var string stateLabel = "NEUTRAL"
var int stateBarIndex = bar_index

string desiredState = "NEUTRAL"
if score >= accelThreshold
    desiredState := "ACCEL"
else if score <= -decelThreshold
    desiredState := "DECEL"
else if math.abs(score) <= neutralBand
    desiredState := "NEUTRAL"
else
    desiredState := stateLabel

bool allowSwitch = desiredState == stateLabel or bar_index - stateBarIndex >= holdBars or desiredState == "NEUTRAL"

if desiredState != stateLabel and allowSwitch
    stateLabel := desiredState
    stateBarIndex := bar_index

// === Confidence & Diagnostics ===
maxThreshold = math.max(accelThreshold, decelThreshold)
confidence = maxThreshold == 0.0 ? 0.0 : math.min(math.abs(score) / maxThreshold, 1.0)
confidencePct = math.round(confidence * 100.0)

color stateColor = stateLabel == "ACCEL" ? color.new(color.teal, 0) : stateLabel == "DECEL" ? color.new(color.red, 0) : color.new(color.gray, 30)

if showStateText
    string jpState = stateLabel == "ACCEL" ? "\u52A0\u901F\u4E2D" : stateLabel == "DECEL" ? "\u6E1B\u901F\u4E2D" : "\u4E2D\u7ACB"
    color jpTextColor = stateLabel == "ACCEL" ? color.teal : stateLabel == "DECEL" ? color.red : color.gray
    float atrForLabel = nz(signalATR, ta.atr(atrLen))
    float offsetValue = stateTextOffsetATR * atrForLabel
    float anchorPrice = signalClose
    if stateLabel == "ACCEL"
        anchorPrice += offsetValue
    else if stateLabel == "DECEL"
        anchorPrice -= offsetValue
    if na(stateTextLabel)
        stateTextLabel := label.new(bar_index, anchorPrice, jpState, xloc=xloc.bar_index, textcolor=jpTextColor, style=label.style_label_left, color=color.new(stateColor, 70))
    else
        label.set_xy(stateTextLabel, bar_index, anchorPrice)
        label.set_text(stateTextLabel, jpState)
        label.set_textcolor(stateTextLabel, jpTextColor)
        label.set_color(stateTextLabel, color.new(stateColor, 70))
else if not na(stateTextLabel)
    label.delete(stateTextLabel)
    stateTextLabel := na

bgcolor(color.new(stateColor, 85), title="State Background")

plot(score, "Acceleration Score", color=color.white, linewidth=2)
hline(accelThreshold, "ACCEL Threshold", color=color.teal, linestyle=hline.style_dashed)
hline(-decelThreshold, "DECEL Threshold", color=color.red, linestyle=hline.style_dashed)
hline(0.0, "Zero", color=color.new(color.gray, 60))

plotchar(stateLabel == "ACCEL", "ACCEL Flag", "A", location.top, color=color.teal, size=size.tiny)
plotchar(stateLabel == "DECEL", "DECEL Flag", "D", location.bottom, color=color.red, size=size.tiny)

// === Table Output ===
var table infoTable = table.new(position.top_right, 1, 6, border_width=1)
if barstate.islast
    string headerText = "State: " + stateLabel + " (" + str.tostring(confidencePct, format.mintick) + "%)"
    table.cell(infoTable, 0, 0, headerText, text_color=color.white, bgcolor=color.new(stateColor, 60))
    table.cell(infoTable, 0, 1, "Score " + str.tostring(score, format.mintick), text_color=color.white)
    table.cell(infoTable, 0, 2, "Leg " + str.tostring(legComponent, format.mintick) + " | ATR " + str.tostring(atrComponent, format.mintick), text_color=color.white)
    table.cell(infoTable, 0, 3, "Vol " + str.tostring(volComponent, format.mintick) + " | PA " + str.tostring(priceActionComponent, format.mintick), text_color=color.white)
    table.cell(infoTable, 0, 4, "Align " + str.tostring(alignComponent, format.mintick) + " | Dir " + str.tostring(baseDir, format.mintick), text_color=color.white)
    table.cell(infoTable, 0, 5, "TrendHTF " + str.tostring(trendDir, format.mintick) + " | TrendLTF " + str.tostring(signalDir, format.mintick), text_color=color.white)

// === Alerts ===
alertcondition(stateLabel == "ACCEL" and stateLabel[1] != "ACCEL", "State: ACCEL", "Acceleration detected on {{ticker}} @ {{interval}}")
alertcondition(stateLabel == "DECEL" and stateLabel[1] != "DECEL", "State: DECEL", "Deceleration detected on {{ticker}} @ {{interval}}")
alertcondition(stateLabel == "NEUTRAL" and stateLabel[1] != "NEUTRAL", "State: NEUTRAL", "Neutral state on {{ticker}} @ {{interval}}")



